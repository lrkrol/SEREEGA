% [scalpdata, sourcedata] = generate_scalpdata(component, leadfield, epochs, varargin)
%
%       Generates simulated scalp data by simulating all signals in all
%       components, projecting them through the leadfield using the given
%       source and orientation, and summing them together, for all of the
%       indicated epochs. Also outputs the underlying component source
%       activation.
%
% In:
%       component - 1-by-n struct of components (see utl_check_component)
%       leadfield - a leadfield struct as generated by one of the lf_generate
%                   functions
%       epochs - single epoch configuration struct containing at least
%                sampling rate in Hz (field name 'srate'), epoch length in ms
%                 ('length'), and the total number of epochs ('n')
%
% Optional (key-value pairs):
%       normaliseLeadfield - 0|1, whether or not to normalise the
%                            leadfields before  projecting the signal to
%                            have the most extreme value be either 1 or -1,
%                            depending on its sign. default: 0
%       normaliseOrientation - 0|1, as above, except for orientation,
%                              default: 0
%       sensorNoise - maximum absolute amplitude of uncorrelated uniform 
%                     white noise added to the final scalp data. default: 0
%                     see utl_add_sensornoise and/or utl_mix_data for more
%                     options.
%       showProgress - 1|0, whether or not to show progress updates in the
%                      console, default: 1
%       useParallelPool - 1|0, whether or not to use parallel processing
%                         where available. default: 1
%       legacy_rndmultsrc - 0|1, reinstates legacy (<=1.0.19) behaviour
%                           where, when multiple sources are indicated in
%                           one component, only one random source is
%                           selected for each epoch's projection. new
%                           behaviour takes the sum of the source
%                           projections. default: 0
%
% Out:
%       scalpdata - channels x samples x epochs array of simulated scalp
%                   data
%       sourcedata - ncomponents x samples x epochs array of the component
%                    source activations
%
% Usage example:
%       >> lf = lf_generate_fromnyhead();
%       >> epochs = struct('n', 100, 'srate', 1000, 'length', 1000);
%       >> erp = struct('type', 'erp', 'peakLatency', 200, ...
%       >>      'peakWidth', 100, 'peakAmplitude', 1);
%       >> comp = utl_create_component(1, erp, lf);
%       >> scalpdata = generate_scalpdata(comp, lf, epochs);
% 
%                    Copyright 2017, 2018, 2023 Laurens R. Krol
%                    Team PhyPA, Biological Psychology and Neuroergonomics,
%                    Berlin Institute of Technology

% 2023-07-10 lrk
%   - Added optional useParallelPool argument
% 2021-07-05 lrk
%   - Switched to a parallel loop to generate the epochs (where available)
% 2020-01-11 lrk
%   - Changed behaviour when one component contains multiple sources. The
%     projections from each source are now summed together. Previous
%     behaviour, using only one randomly chosen souce per epoch, can be
%     reinstated with the argument legacy_rndmultsrc.
% 2018-04-05 lrk
%   - Added ETA to waitbar
% 2018-01-10 lrk
%   - Added sensor noise
% 2017-10-11 lrk
%   - Added source activation output
% 2017-08-03 lrk
%   - Switched normalisation defaults to 0
% 2017-06-14 First version

% This file is part of Simulating Event-Related EEG Activity (SEREEGA).

% SEREEGA is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.

% SEREEGA is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with SEREEGA.  If not, see <http://www.gnu.org/licenses/>.

function [scalpdata, sourcedata] = generate_scalpdata(component, leadfield, epochs, varargin)

% parsing input
p = inputParser;

addRequired(p, 'component', @isstruct);
addRequired(p, 'leadfield', @isstruct);
addRequired(p, 'epochs', @isstruct);

addParameter(p, 'normaliseLeadfield', 0, @isnumeric);
addParameter(p, 'normaliseOrientation', 0, @isnumeric);
addParameter(p, 'sensorNoise', 0, @isnumeric);
addParameter(p, 'showProgress', 1, @isnumeric);
addParameter(p, 'useParallelPool', 1, @isnumeric);
addParameter(p, 'legacy_rndmultsrc', 0, @isnumeric);

parse(p, component, leadfield, epochs, varargin{:})

component = p.Results.component;
leadfield = p.Results.leadfield;
epochs = p.Results.epochs;
normaliseLeadfield = p.Results.normaliseLeadfield;
normaliseOrientation = p.Results.normaliseOrientation;
sensorNoise = p.Results.sensorNoise;
showProgress = p.Results.showProgress;
useParallelPool = p.Results.useParallelPool;
legacy_rndmultsrc = p.Results.legacy_rndmultsrc;

component = utl_check_component(component, leadfield);

scalpdata = zeros(numel(leadfield.chanlocs), floor((epochs.length/1000)*epochs.srate), epochs.n);
sourcedata = zeros(length(component), floor((epochs.length/1000)*epochs.srate), epochs.n);

% starting parallel pool if available, or skipping its autocreation
if ~useParallelPool
    ps = parallel.Settings;
    originalSetting = ps.Pool.AutoCreate;
    ps.Pool.AutoCreate = false;
elseif exist('gcp', 'file') && isempty(gcp('nocreate'))
    parpool;
end

fprintf('Generating scalp data... ');
if showProgress
    progress_start = tic;
    utl_show_progress_timetocomplete;
    utl_show_progress_parfor(epochs.n);
end

% for each epoch...
parfor e = 1:epochs.n
    
    epochsourcedata = zeros(length(component), floor((epochs.length/1000)*epochs.srate));
    epochscalpdata = zeros(numel(leadfield.chanlocs), floor((epochs.length/1000)*epochs.srate), numel(component));
    
    % for each component...
    for c = 1:numel(component)

        % getting component's sum signal
        componentsignal = generate_signal_fromcomponent(component(c), epochs, 'epochNumber', e);
        epochsourcedata(c,:) = componentsignal;

        if legacy_rndmultsrc
            % legacy behaviour: obtaining single random source
            n = randperm(numel(component(c).source));
            n = n(1);
            source = component(c).source(n);

            % obtaining orientation
            orientation = component(c).orientation(n,:);
            orientationDv = component(c).orientationDv(n,:);
            orientation = utl_apply_dvslopeshift(orientation, orientationDv, zeros(size(orientation)), e, epochs.n);
            if all(orientation == zeros(1,3))
                warning('all-zero orientation for component %d', c);
            end

            % projecting signal
            epochscalpdata(:,:,c) = lf_project_signal(leadfield, componentsignal, source, orientation, ...
                    'normaliseLeadfield', normaliseLeadfield, ...
                    'normaliseOrientation', normaliseOrientation);
        else
            % new behaviour: projecting through each source and taking sum
            sourceprojecteddata = [];
            for s = 1:numel(component(c).source)
                % obtaining orientation
                orientation = component(c).orientation(s,:);
                orientationDv = component(c).orientationDv(s,:);
                orientation = utl_apply_dvslopeshift(orientation, orientationDv, zeros(size(orientation)), e, epochs.n);
                if all(orientation == zeros(1,3))
                    warning('all-zero orientation for component %d', c);
                end
                
                % projecting signal
                source = component(c).source(s);
                sourceprojecteddata = cat(3, sourceprojecteddata, ...
                        lf_project_signal(leadfield, componentsignal, source, orientation, ...
                                'normaliseLeadfield', normaliseLeadfield, ...
                                'normaliseOrientation', normaliseOrientation));
            end
            epochscalpdata(:,:,c) = sum(sourceprojecteddata, 3);
        end
        
    end
    
    % combining (projected) component signals into single epoch
    sourcedata(:,:,e) = epochsourcedata;
    scalpdata(:,:,e) = sum(epochscalpdata, 3);
        
    if showProgress
        % keeping time
        p = utl_show_progress_parfor();
        utl_show_progress_timetocomplete(p/100, [], [], progress_start);
    end
    
end

if showProgress
    % deleting temp file
    utl_show_progress_parfor(0);
end

% reverting parpool settings
if ~useParallelPool
    ps.Pool.AutoCreate = originalSetting;
end

% adding sensor noise
scalpdata = utl_add_sensornoise(scalpdata, 'amplitude', sensorNoise);

end